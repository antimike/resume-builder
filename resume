#!/bin/env python3

from __future__ import annotations

import argparse
import inspect
import logging
import subprocess
import sys
from dataclasses import dataclass, field
from enum import StrEnum
from functools import partial, reduce, singledispatch
from itertools import chain, zip_longest
from pathlib import Path
from typing import Mapping, Self, Sequence

import yaml
from addict import Addict
from dataclasses_json import DataClassJsonMixin
from jinja2 import Environment, FileSystemLoader
from rich.logging import RichHandler

logger = logging.getLogger(__name__)
logger.addHandler(RichHandler())
logger.setLevel(logging.INFO)

DEFAULT_CONFIG = Path(__file__).parent.joinpath("default_config.yaml")
TEMPLATE = Path(__file__).parent.joinpath("resume.tex.j2")


def batch(collection, batch_size):
    yield from zip_longest(*(iter(collection),) * batch_size)


class ResumeLoader(yaml.SafeLoader):
    class _TagConstructor:
        def __init__(self, func):
            self.name = func.__name__
            self.registered = {t: None for t in ("Sequence", "str", "Mapping")}
            self.register(func)

        def tagger(self, tag, template):
            def _tagger(loader, node):
                return self.__call__(node, loader, tag, template)

            return _tagger

        def register(self, func):
            self.registered[self._get_node_type(func).split(".")[-1]] = func

        @classmethod
        def _get_node_type(cls, func):
            sig = inspect.signature(func)
            first_param = next(iter(sig.parameters))
            return inspect.get_annotations(func).get(first_param, None)

        def __call__(self, node, loader, tag, template):
            if isinstance(node, yaml.ScalarNode):
                content = loader.construct_scalar(node)
                func = self.registered["str"]
            elif isinstance(node, yaml.MappingNode):
                content = loader.construct_mapping(node, deep=True)
                func = self.registered["Mapping"]
            elif isinstance(node, yaml.SequenceNode):
                content = loader.construct_sequence(node, deep=True)
                func = self.registered["Sequence"]
            # self.registered[None] is the default
            if func is None:
                if None not in self.registered:
                    raise TypeError(
                        f"No constructor registered for node type {node.__class__!r}"
                    )
                func = self.registered[None]
            return func(content, loader, tag=tag, template=template)

    def __init__(self, stream):
        self._search_paths = [DEFAULT_CONFIG.parent]
        try:
            self._search_paths.append(Path(stream.name).parent)
        except AttributeError:
            pass
        super().__init__(stream)

    def find_configs(self, name):
        name = name.removesuffix(".yaml").removesuffix(".yml")
        globs = [path.rglob(f"{name}.y?ml") for path in self._search_paths]
        yield from chain(*globs)

    @classmethod
    def tag_constructor(cls, *tags, **tag_templates):
        def decorator(func):
            ctor = cls._TagConstructor(func)
            for tag in tags:
                cls.add_constructor(
                    f"!{tag.removeprefix('!')}",
                    ctor.tagger(tag, None),
                )
            for tag, template in tag_templates.items():
                cls.add_constructor(
                    f"!{tag.removeprefix('!')}",
                    ctor.tagger(tag, template),
                )
            return ctor

        return decorator


@ResumeLoader.tag_constructor("include")
def include(content: str, loader, tag=None, template=None):
    try:
        with next(loader.find_configs(content)).open("r") as file:
            docs = list(yaml.load_all(file, loader.__class__))
            if all(isinstance(doc, Sequence) for doc in docs):
                return reduce(lambda res, doc: res + list(doc), docs, [])
            else:
                return docs
    except StopIteration:
        raise KeyError(f"No config file for resume item {content!r} was found")


@ResumeLoader.tag_constructor("textbf", "emph")
def latex_style(content: str, loader, tag=None, template=None):
    return r"\%s{%s}" % (tag, content)


@ResumeLoader.tag_constructor(
    list_double=r"\cvlistdoubleitem{%s}{%s}",
    list_computer=r"\cvcomputer{%s}{%s}{%s}{%s}",
)
def batch_collection(content: Sequence, loader, tag=None, template=None):
    ret = []
    for first, second in batch(content, 2):
        if tag == "list_computer":
            args = (first.get("title", ""), first.get("description", ""))
            args += (
                (second.get("title", ""), second.get("description", ""))
                if second is not None
                else ("", "")
            )
        elif tag == "list_double":
            args = ()
            for item in (first, second):
                if item is None:
                    args += ("",)
                elif isinstance(item, dict) and "title" in item:
                    arg = item["title"]
                    if "description" in item:
                        arg += f": {item['description']}"
                    args += (arg,)
                else:
                    args += (str(item),)
        ret.append(template % args)
    return ret


@batch_collection.register
def batch_mapping(content: Mapping, loader, tag=None, template=None):
    def stringify(val):
        if isinstance(val, list):
            return ", ".join(val)
        else:
            return str(val)

    ret = []
    m = {k: stringify(v) for k, v in content.items()}
    for first, second in batch(m.items(), 2):
        if second is None:
            second = ("", "")
        ret.append(template % (first + second))
    return ret


@ResumeLoader.tag_constructor(list_single=r"\cvlistitem{%s}")
def listitem(content: str, loader, tag=None, template=None):
    return template % content


@listitem.register
def listitem_sequence(content: Sequence, loader, tag=None, template=None):
    ret = []
    for item in content:
        if isinstance(item, str):
            ret.append(template % item)
        elif isinstance(item, dict):
            content = item["title"]
            if "description" in item:
                content += f": {item['description']}"
            ret.append(content)
            if "items" in item:
                ret.extend(item["items"])


@listitem.register
def listitem_mapping(content: Mapping, loader, tag=None, template=None):
    return [template % f"{k}: {v}" for k, v in content.items()]


@dataclass(kw_only=True)
class ResumeConfig(DataClassJsonMixin):
    def format(self, fmt: str) -> str:
        return fmt.format(**self.to_dict())

    @classmethod
    def from_yaml(cls, markup) -> Self:
        return cls.from_dict(yaml.load(markup, ResumeLoader))


@dataclass
class ResumeItem(ResumeConfig):
    title: str | None = None
    description: str | list[str] | None = None
    items: list[ResumeItem | str] = field(default_factory=list)


@dataclass
class ResumeTheme(ResumeConfig):
    color: str
    style: str
    font_size: int


@dataclass
class Address(ResumeConfig):
    street: str
    city: str
    state: str
    zip: str


@dataclass
class PersonalData(ResumeItem):
    first_name: str = ""
    last_name: str = ""
    desired_title: str = ""
    address: Address = field(default_factory=Address)
    mobile: str = ""
    email: str = ""


@dataclass
class Resume(ResumeConfig):
    theme: ResumeTheme
    personal_data: PersonalData
    sections: list[ResumeItem]


def get_resume_template():
    jinja_env = Environment(
        block_start_string="<&",
        block_end_string="&>",
        variable_start_string="<@",
        variable_end_string="@>",
        comment_start_string="<#",
        comment_end_string="#>",
        trim_blocks=True,
        lstrip_blocks=True,
        loader=FileSystemLoader(TEMPLATE.parent),
        extensions=["jinja2.ext.do"],
    )
    return jinja_env.get_template(TEMPLATE.name)


def read_config(path: Path) -> list[ResumeItem]:
    with path.open("r") as file:
        return list(map(ResumeItem.from_dict, yaml.safe_load_all(file)))


def find_resumes(search_str):
    return [
        p
        for p in TEMPLATE.parent.rglob("resume.yaml")
        if p.parent.name.lower().startswith(search_str.lower())
    ]


def build_resume(path):
    resume = path.parent.joinpath("resume.tex")
    logger.info(
        "Rendering %s from template %s and configuration %s",
        resume,
        TEMPLATE,
        path,
    )
    tmpl = get_resume_template()
    with path.open("r") as file:
        config = Addict(yaml.unsafe_load(file))
    resume.write_text(tmpl.render(config=config))
    logger.info("Compiling TeX file %s using %s", resume, "pdflatex")
    subprocess.run(
        ["pdflatex", str(resume)],
        cwd=path.parent,
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        stderr=subprocess.STDOUT,
    )


def get_cli_opts(args: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    commands = parser.add_subparsers(title="commands", required=True, dest="command")
    add = commands.add_parser(
        "add",
        help="add subdirectories and config files for new resumes",
    )
    edit = commands.add_parser(
        "edit",
        help="edit and rebuild resume (uses $EDITOR)",
    )
    build = commands.add_parser(
        "build",
        help="build resumes from the config files",
    )
    add.add_argument(
        "name",
        help="name of resume to add",
        nargs="+",
    )
    edit.add_argument("name", help="name of resume to edit")
    build.add_argument(
        "name",
        help="name of resume to build (if not provided, the current directory will be built)",
        nargs="*",
    )
    return parser.parse_args(args)


if __name__ == "__main__":
    opts = get_cli_opts(sys.argv[1:])
    status = 0
    logger.debug(opts)
    if opts.command == "add":
        for name in opts.name:
            logger.info("Creating subdirectory and config file for resume %r", name)
            try:
                dest = TEMPLATE.parent.joinpath(name)
                dest.mkdir(exist_ok=False)
                dest.joinpath("resume.yaml").write_text(DEFAULT_CONFIG.read_text())
            except FileExistsError:
                logger.error("Target %r already exists!", name)
    elif opts.command == "build":
        for name in opts.name:
            logger.info("Building resume %r", name)
            try:
                resumes = find_resumes(name)
                if not resumes:
                    raise FileNotFoundError(name)
                if len(resumes) > 1:
                    logger.warning("Resume name %r is ambiguous", name)
                    status += 1
                else:
                    build_resume(resumes.pop())
            except FileNotFoundError:
                logger.error("Could not find resume %r", name)
                status += 1
            except Exception:
                raise
    elif opts.command == "edit":
        raise NotImplementedError()

    sys.exit(status)
